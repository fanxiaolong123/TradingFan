"""
‰∫§ÊòìÊó•ÂøóÈ°µÈù¢

Êèê‰æõ‰∫§ÊòìËÆ∞ÂΩïÂíåÁ≥ªÁªüÊó•ÂøóÂ±ïÁ§∫ÔºåÂåÖÊã¨Ôºö
- ‰∫§ÊòìËÆ∞ÂΩïÊü•ËØ¢ÂíåËøáÊª§
- Á≥ªÁªüÊó•ÂøóÂÆûÊó∂ÊòæÁ§∫
- Êó•ÂøóÂØºÂá∫ÂäüËÉΩ
- ÈîôËØØÊó•ÂøóÂëäË≠¶
"""

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, Any, List
from datetime import datetime, timedelta
import numpy as np
import sys
from pathlib import Path

# Ê∑ªÂä†È°πÁõÆË∑ØÂæÑ
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))


class TradeLogger:
    """
    ‰∫§ÊòìÊó•ÂøóÈ°µÈù¢Á±ª
    
    Ë¥üË¥£Ôºö
    - ‰∫§ÊòìËÆ∞ÂΩïÂ±ïÁ§∫ÂíåÊü•ËØ¢
    - Á≥ªÁªüÊó•ÂøóÂÆûÊó∂ÁõëÊéß
    - Êó•ÂøóËøáÊª§ÂíåÊêúÁ¥¢
    - ‰∫§ÊòìÁªüËÆ°ÂàÜÊûê
    - Êó•ÂøóÂØºÂá∫ÂäüËÉΩ
    """
    
    def __init__(self, trading_system: Dict[str, Any]):
        """
        ÂàùÂßãÂåñ‰∫§ÊòìÊó•ÂøóÂô®
        
        Args:
            trading_system: ‰∫§ÊòìÁ≥ªÁªüÁªÑ‰ª∂Â≠óÂÖ∏
        """
        self.trading_system = trading_system
        self.broker = trading_system['broker']
        self.strategies = trading_system.get('strategies', {})
        
        # ÁîüÊàêÁ§∫‰æãÊï∞ÊçÆ
        self._generate_sample_data()
    
    def _generate_sample_data(self):
        """ÁîüÊàêÁ§∫‰æã‰∫§ÊòìËÆ∞ÂΩïÂíåÁ≥ªÁªüÊó•Âøó"""
        # ÁîüÊàê‰∫§ÊòìËÆ∞ÂΩï
        self.trade_records = []
        base_time = datetime.now() - timedelta(days=7)
        
        for i in range(50):  # ÁîüÊàê50Êù°‰∫§ÊòìËÆ∞ÂΩï
            trade_time = base_time + timedelta(hours=i*3)
            symbols = ['BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'BNBUSDT']
            symbol = symbols[i % len(symbols)]
            
            # ÁîüÊàê‰π∞ÂÖ•/ÂçñÂá∫‰∫§Êòì
            if i % 2 == 0:  # ‰π∞ÂÖ•
                self.trade_records.append({
                    'id': f"T{i+1:04d}",
                    'time': trade_time,
                    'strategy': 'ÂùáÂÄºÂõûÂΩíÁ≠ñÁï•',
                    'symbol': symbol,
                    'side': 'BUY',
                    'type': 'MARKET',
                    'quantity': round(np.random.uniform(0.001, 0.1), 6),
                    'price': round(np.random.uniform(40000, 50000) if 'BTC' in symbol else np.random.uniform(2000, 3000), 2),
                    'amount': round(np.random.uniform(500, 2000), 2),
                    'commission': round(np.random.uniform(0.5, 2.0), 2),
                    'status': 'FILLED',
                    'pnl': 0.0
                })
            else:  # ÂçñÂá∫
                self.trade_records.append({
                    'id': f"T{i+1:04d}",
                    'time': trade_time,
                    'strategy': 'ÂùáÂÄºÂõûÂΩíÁ≠ñÁï•',
                    'symbol': symbol,
                    'side': 'SELL',
                    'type': 'MARKET',
                    'quantity': round(np.random.uniform(0.001, 0.1), 6),
                    'price': round(np.random.uniform(40000, 50000) if 'BTC' in symbol else np.random.uniform(2000, 3000), 2),
                    'amount': round(np.random.uniform(500, 2000), 2),
                    'commission': round(np.random.uniform(0.5, 2.0), 2),
                    'status': 'FILLED',
                    'pnl': round(np.random.uniform(-50, 100), 2)
                })
        
        # ÁîüÊàêÁ≥ªÁªüÊó•Âøó
        self.system_logs = []
        log_levels = ['INFO', 'WARNING', 'ERROR', 'DEBUG']
        log_sources = ['Á≠ñÁï•', '‰∫§Êòì', 'È£éÊéß', 'Êï∞ÊçÆ', 'Á≥ªÁªü']
        
        for i in range(100):  # ÁîüÊàê100Êù°Á≥ªÁªüÊó•Âøó
            log_time = base_time + timedelta(minutes=i*5)
            level = log_levels[i % len(log_levels)]
            source = log_sources[i % len(log_sources)]
            
            # Ê†πÊçÆÁ∫ßÂà´ÂíåÊù•Ê∫êÁîüÊàê‰∏çÂêåÁöÑÊó•ÂøóÊ∂àÊÅØ
            if level == 'INFO':
                messages = [
                    f"{source}Ê®°ÂùóÊ≠£Â∏∏ËøêË°å",
                    f"Á≠ñÁï•‰ø°Âè∑ÁîüÊàê: {symbols[i % len(symbols)]}",
                    f"Êï∞ÊçÆÊõ¥Êñ∞ÂÆåÊàê: {symbols[i % len(symbols)]}",
                    f"Ë¥¶Êà∑‰ΩôÈ¢ùÊõ¥Êñ∞"
                ]
            elif level == 'WARNING':
                messages = [
                    f"ÊåÅ‰ªìÊØî‰æãÊé•Ëøë‰∏äÈôê: {symbols[i % len(symbols)]}",
                    f"ÁΩëÁªúÂª∂ËøüËæÉÈ´ò",
                    f"Êï∞ÊçÆÂª∂Ëøü: {symbols[i % len(symbols)]}",
                    f"È£éÊéßËßÑÂàôËß¶Âèë"
                ]
            elif level == 'ERROR':
                messages = [
                    f"ËÆ¢ÂçïÊâßË°åÂ§±Ë¥•: {symbols[i % len(symbols)]}",
                    f"Êï∞ÊçÆËé∑ÂèñÂ§±Ë¥•",
                    f"ËøûÊé•Ë∂ÖÊó∂",
                    f"APIÈôêÊµÅ"
                ]
            else:  # DEBUG
                messages = [
                    f"Ë∞ÉËØï‰ø°ÊÅØ: ËÆ°ÁÆó‰ø°Âè∑‰∏≠",
                    f"Êï∞ÊçÆÂ§ÑÁêÜ: {symbols[i % len(symbols)]}",
                    f"Á≠ñÁï•ÂèÇÊï∞Êõ¥Êñ∞",
                    f"Á≥ªÁªüÁä∂ÊÄÅÊ£ÄÊü•"
                ]
            
            self.system_logs.append({
                'time': log_time,
                'level': level,
                'source': source,
                'message': messages[i % len(messages)]
            })
    
    def render(self):
        """Ê∏≤Êüì‰∫§ÊòìÊó•ÂøóÈ°µÈù¢"""
        st.header("üìÑ ‰∫§ÊòìÊó•Âøó‰∏≠ÂøÉ")
        
        # È°µÈù¢ÂØºËà™
        tab1, tab2, tab3, tab4 = st.tabs(["üìä ‰∫§ÊòìËÆ∞ÂΩï", "üìã Á≥ªÁªüÊó•Âøó", "üìà ‰∫§ÊòìÁªüËÆ°", "üì§ Êó•ÂøóÂØºÂá∫"])
        
        with tab1:
            self._render_trade_records()
        
        with tab2:
            self._render_system_logs()
        
        with tab3:
            self._render_trade_statistics()
        
        with tab4:
            self._render_log_export()
    
    def _render_trade_records(self):
        """Ê∏≤Êüì‰∫§ÊòìËÆ∞ÂΩïÈ°µÈù¢"""
        st.subheader("üìä ‰∫§ÊòìËÆ∞ÂΩï")
        
        # ËøáÊª§Âô®
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            strategy_filter = st.selectbox(
                "Á≠ñÁï•",
                options=["ÂÖ®ÈÉ®"] + list(set([trade['strategy'] for trade in self.trade_records])),
                index=0
            )
        
        with col2:
            symbol_filter = st.selectbox(
                "‰∫§ÊòìÂØπ",
                options=["ÂÖ®ÈÉ®"] + list(set([trade['symbol'] for trade in self.trade_records])),
                index=0
            )
        
        with col3:
            side_filter = st.selectbox(
                "ÊñπÂêë",
                options=["ÂÖ®ÈÉ®", "BUY", "SELL"],
                index=0
            )
        
        with col4:
            status_filter = st.selectbox(
                "Áä∂ÊÄÅ",
                options=["ÂÖ®ÈÉ®", "FILLED", "CANCELLED", "PENDING"],
                index=0
            )
        
        # Êó•ÊúüËåÉÂõ¥ËøáÊª§
        col1, col2 = st.columns(2)
        with col1:
            start_date = st.date_input(
                "ÂºÄÂßãÊó•Êúü",
                value=datetime.now() - timedelta(days=7)
            )
        with col2:
            end_date = st.date_input(
                "ÁªìÊùüÊó•Êúü",
                value=datetime.now()
            )
        
        # Â∫îÁî®ËøáÊª§Âô®
        filtered_trades = self._filter_trades(
            strategy_filter, symbol_filter, side_filter, status_filter, start_date, end_date
        )
        
        # ÁªüËÆ°Ê¶ÇËßà
        if filtered_trades:
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                total_trades = len(filtered_trades)
                st.metric("ÊÄª‰∫§ÊòìÊï∞", total_trades)
            
            with col2:
                total_volume = sum(trade['amount'] for trade in filtered_trades)
                st.metric("ÊÄª‰∫§ÊòìÈáëÈ¢ù", f"{total_volume:,.2f} USDT")
            
            with col3:
                total_pnl = sum(trade['pnl'] for trade in filtered_trades)
                st.metric("ÊÄªÁõà‰∫è", f"{total_pnl:+.2f} USDT")
            
            with col4:
                total_commission = sum(trade['commission'] for trade in filtered_trades)
                st.metric("ÊÄªÊâãÁª≠Ë¥π", f"{total_commission:.2f} USDT")
        
        # ‰∫§ÊòìËÆ∞ÂΩïË°®Ê†º
        st.markdown("#### üìã ‰∫§ÊòìËØ¶ÊÉÖ")
        
        if filtered_trades:
            # ËΩ¨Êç¢‰∏∫DataFrame
            df_trades = pd.DataFrame(filtered_trades)
            
            # Ê†ºÂºèÂåñÊòæÁ§∫
            df_trades['time'] = pd.to_datetime(df_trades['time']).dt.strftime('%Y-%m-%d %H:%M:%S')
            df_trades['quantity'] = df_trades['quantity'].apply(lambda x: f"{x:.6f}")
            df_trades['price'] = df_trades['price'].apply(lambda x: f"{x:.2f}")
            df_trades['amount'] = df_trades['amount'].apply(lambda x: f"{x:.2f}")
            df_trades['commission'] = df_trades['commission'].apply(lambda x: f"{x:.2f}")
            df_trades['pnl'] = df_trades['pnl'].apply(lambda x: f"{x:+.2f}")
            
            # ÈáçÂëΩÂêçÂàó
            df_trades = df_trades.rename(columns={
                'id': 'ID',
                'time': 'Êó∂Èó¥',
                'strategy': 'Á≠ñÁï•',
                'symbol': '‰∫§ÊòìÂØπ',
                'side': 'ÊñπÂêë',
                'type': 'Á±ªÂûã',
                'quantity': 'Êï∞Èáè',
                'price': '‰ª∑Ê†º',
                'amount': 'ÈáëÈ¢ù',
                'commission': 'ÊâãÁª≠Ë¥π',
                'status': 'Áä∂ÊÄÅ',
                'pnl': 'Áõà‰∫è'
            })
            
            # ÂàÜÈ°µÊòæÁ§∫
            page_size = st.slider("ÊØèÈ°µÊòæÁ§∫", 10, 50, 20)
            total_pages = (len(df_trades) - 1) // page_size + 1
            
            if total_pages > 1:
                page = st.selectbox("È°µÁ†Å", range(1, total_pages + 1))
                start_idx = (page - 1) * page_size
                end_idx = start_idx + page_size
                df_display = df_trades.iloc[start_idx:end_idx]
            else:
                df_display = df_trades
            
            st.dataframe(
                df_display,
                use_container_width=True,
                hide_index=True
            )
        else:
            st.info("Ê≤°ÊúâÂåπÈÖçÁöÑ‰∫§ÊòìËÆ∞ÂΩï")
    
    def _filter_trades(self, strategy_filter: str, symbol_filter: str, side_filter: str, 
                      status_filter: str, start_date, end_date) -> List[Dict]:
        """ËøáÊª§‰∫§ÊòìËÆ∞ÂΩï"""
        filtered = []
        
        for trade in self.trade_records:
            # Êó∂Èó¥ËøáÊª§
            trade_date = trade['time'].date()
            if not (start_date <= trade_date <= end_date):
                continue
            
            # Á≠ñÁï•ËøáÊª§
            if strategy_filter != "ÂÖ®ÈÉ®" and trade['strategy'] != strategy_filter:
                continue
            
            # ‰∫§ÊòìÂØπËøáÊª§
            if symbol_filter != "ÂÖ®ÈÉ®" and trade['symbol'] != symbol_filter:
                continue
            
            # ÊñπÂêëËøáÊª§
            if side_filter != "ÂÖ®ÈÉ®" and trade['side'] != side_filter:
                continue
            
            # Áä∂ÊÄÅËøáÊª§
            if status_filter != "ÂÖ®ÈÉ®" and trade['status'] != status_filter:
                continue
            
            filtered.append(trade)
        
        return filtered
    
    def _render_system_logs(self):
        """Ê∏≤ÊüìÁ≥ªÁªüÊó•ÂøóÈ°µÈù¢"""
        st.subheader("üìã Á≥ªÁªüÊó•Âøó")
        
        # ËøáÊª§Âô®
        col1, col2, col3 = st.columns(3)
        
        with col1:
            level_filter = st.selectbox(
                "Êó•ÂøóÁ∫ßÂà´",
                options=["ÂÖ®ÈÉ®", "INFO", "WARNING", "ERROR", "DEBUG"],
                index=0
            )
        
        with col2:
            source_filter = st.selectbox(
                "Êù•Ê∫ê",
                options=["ÂÖ®ÈÉ®"] + list(set([log['source'] for log in self.system_logs])),
                index=0
            )
        
        with col3:
            search_text = st.text_input(
                "ÊêúÁ¥¢ÂÖ≥ÈîÆËØç",
                placeholder="ËæìÂÖ•ÂÖ≥ÈîÆËØçÊêúÁ¥¢Êó•Âøó..."
            )
        
        # ÂÆûÊó∂Âà∑Êñ∞ÂºÄÂÖ≥
        auto_refresh = st.checkbox("Ëá™Âä®Âà∑Êñ∞", value=False)
        if auto_refresh:
            st.info("‚ö° Ëá™Âä®Âà∑Êñ∞Â∑≤ÂêØÁî®")
        
        # Â∫îÁî®ËøáÊª§Âô®
        filtered_logs = self._filter_logs(level_filter, source_filter, search_text)
        
        # Êó•ÂøóÁ∫ßÂà´ÁªüËÆ°
        if filtered_logs:
            level_counts = {}
            for log in filtered_logs:
                level = log['level']
                level_counts[level] = level_counts.get(level, 0) + 1
            
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("INFO", level_counts.get('INFO', 0))
            with col2:
                st.metric("WARNING", level_counts.get('WARNING', 0))
            with col3:
                st.metric("ERROR", level_counts.get('ERROR', 0))
            with col4:
                st.metric("DEBUG", level_counts.get('DEBUG', 0))
        
        # Êó•ÂøóÂàóË°®
        st.markdown("#### üìú Êó•ÂøóËØ¶ÊÉÖ")
        
        if filtered_logs:
            # ÊúÄÊñ∞Êó•ÂøóÂú®Ââç
            filtered_logs.sort(key=lambda x: x['time'], reverse=True)
            
            # ÂàÜÈ°µ
            page_size = st.slider("ÊØèÈ°µÊòæÁ§∫Êó•Âøó", 20, 100, 50)
            total_pages = (len(filtered_logs) - 1) // page_size + 1
            
            if total_pages > 1:
                page = st.selectbox("È°µÁ†Å", range(1, total_pages + 1), key="log_page")
                start_idx = (page - 1) * page_size
                end_idx = start_idx + page_size
                logs_display = filtered_logs[start_idx:end_idx]
            else:
                logs_display = filtered_logs
            
            # ÊòæÁ§∫Êó•Âøó
            for log in logs_display:
                # Ê†πÊçÆÁ∫ßÂà´ËÆæÁΩÆÈ¢úËâ≤
                if log['level'] == 'ERROR':
                    st.error(f"üî¥ [{log['time'].strftime('%H:%M:%S')}] {log['source']} - {log['message']}")
                elif log['level'] == 'WARNING':
                    st.warning(f"üü° [{log['time'].strftime('%H:%M:%S')}] {log['source']} - {log['message']}")
                elif log['level'] == 'INFO':
                    st.info(f"üîµ [{log['time'].strftime('%H:%M:%S')}] {log['source']} - {log['message']}")
                else:  # DEBUG
                    st.text(f"‚ö™ [{log['time'].strftime('%H:%M:%S')}] {log['source']} - {log['message']}")
        else:
            st.info("Ê≤°ÊúâÂåπÈÖçÁöÑÊó•ÂøóËÆ∞ÂΩï")
    
    def _filter_logs(self, level_filter: str, source_filter: str, search_text: str) -> List[Dict]:
        """ËøáÊª§Á≥ªÁªüÊó•Âøó"""
        filtered = []
        
        for log in self.system_logs:
            # Á∫ßÂà´ËøáÊª§
            if level_filter != "ÂÖ®ÈÉ®" and log['level'] != level_filter:
                continue
            
            # Êù•Ê∫êËøáÊª§
            if source_filter != "ÂÖ®ÈÉ®" and log['source'] != source_filter:
                continue
            
            # ÊêúÁ¥¢ËøáÊª§
            if search_text and search_text.lower() not in log['message'].lower():
                continue
            
            filtered.append(log)
        
        return filtered
    
    def _render_trade_statistics(self):
        """Ê∏≤Êüì‰∫§ÊòìÁªüËÆ°È°µÈù¢"""
        st.subheader("üìà ‰∫§ÊòìÁªüËÆ°")
        
        # Êó∂Èó¥ËåÉÂõ¥ÈÄâÊã©
        col1, col2 = st.columns(2)
        with col1:
            start_date = st.date_input(
                "ÂºÄÂßãÊó•Êúü",
                value=datetime.now() - timedelta(days=30),
                key="stat_start"
            )
        with col2:
            end_date = st.date_input(
                "ÁªìÊùüÊó•Êúü",
                value=datetime.now(),
                key="stat_end"
            )
        
        # ËøáÊª§Êï∞ÊçÆ
        filtered_trades = []
        for trade in self.trade_records:
            trade_date = trade['time'].date()
            if start_date <= trade_date <= end_date:
                filtered_trades.append(trade)
        
        if not filtered_trades:
            st.info("ÊâÄÈÄâÊó∂Èó¥ÊÆµÂÜÖÊ≤°Êúâ‰∫§ÊòìÊï∞ÊçÆ")
            return
        
        # Êï¥‰ΩìÁªüËÆ°
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### üìä ‰∫§ÊòìÊ¶ÇËßà")
            
            # Âü∫Êú¨ÁªüËÆ°
            total_trades = len(filtered_trades)
            buy_trades = len([t for t in filtered_trades if t['side'] == 'BUY'])
            sell_trades = len([t for t in filtered_trades if t['side'] == 'SELL'])
            total_volume = sum(trade['amount'] for trade in filtered_trades)
            total_pnl = sum(trade['pnl'] for trade in filtered_trades)
            
            st.metric("ÊÄª‰∫§ÊòìÁ¨îÊï∞", total_trades)
            st.metric("‰π∞ÂÖ•‰∫§Êòì", buy_trades)
            st.metric("ÂçñÂá∫‰∫§Êòì", sell_trades)
            st.metric("ÊÄª‰∫§ÊòìÈ¢ù", f"{total_volume:,.2f} USDT")
            st.metric("ÊÄªÁõà‰∫è", f"{total_pnl:+.2f} USDT")
        
        with col2:
            st.markdown("#### üìà ‰∫§ÊòìÂàÜÂ∏É")
            
            # Êåâ‰∫§ÊòìÂØπÂàÜÂ∏É
            symbol_counts = {}
            for trade in filtered_trades:
                symbol = trade['symbol']
                symbol_counts[symbol] = symbol_counts.get(symbol, 0) + 1
            
            fig = go.Figure(data=[go.Pie(
                labels=list(symbol_counts.keys()),
                values=list(symbol_counts.values()),
                hole=0.3
            )])
            
            fig.update_layout(
                title="‰∫§ÊòìÂØπÂàÜÂ∏É",
                template="plotly_white",
                height=400
            )
            
            st.plotly_chart(fig, use_container_width=True)
        
        # Êó∂Èó¥Â∫èÂàóÂàÜÊûê
        st.markdown("#### üìÖ Êó∂Èó¥Â∫èÂàóÂàÜÊûê")
        
        # ÊåâÊó•ÊúüÊ±áÊÄª
        df_trades = pd.DataFrame(filtered_trades)
        df_trades['date'] = pd.to_datetime(df_trades['time']).dt.date
        
        daily_stats = df_trades.groupby('date').agg({
            'id': 'count',
            'amount': 'sum',
            'pnl': 'sum'
        }).reset_index()
        
        daily_stats.columns = ['date', 'trade_count', 'volume', 'pnl']
        
        # ÂàõÂª∫Êó∂Èó¥Â∫èÂàóÂõæË°®
        col1, col2 = st.columns(2)
        
        with col1:
            # ÊØèÊó•‰∫§ÊòìÈáè
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=daily_stats['date'],
                y=daily_stats['trade_count'],
                mode='lines+markers',
                name='‰∫§ÊòìÁ¨îÊï∞',
                line=dict(color='#1f77b4')
            ))
            
            fig.update_layout(
                title="ÊØèÊó•‰∫§ÊòìÁ¨îÊï∞",
                xaxis_title="Êó•Êúü",
                yaxis_title="‰∫§ÊòìÁ¨îÊï∞",
                template="plotly_white",
                height=400
            )
            
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # ÊØèÊó•Áõà‰∫è
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=daily_stats['date'],
                y=daily_stats['pnl'],
                name='ÊØèÊó•Áõà‰∫è',
                marker_color=['green' if x > 0 else 'red' for x in daily_stats['pnl']]
            ))
            
            fig.update_layout(
                title="ÊØèÊó•Áõà‰∫è",
                xaxis_title="Êó•Êúü",
                yaxis_title="Áõà‰∫è (USDT)",
                template="plotly_white",
                height=400
            )
            
            st.plotly_chart(fig, use_container_width=True)
    
    def _render_log_export(self):
        """Ê∏≤ÊüìÊó•ÂøóÂØºÂá∫È°µÈù¢"""
        st.subheader("üì§ Êó•ÂøóÂØºÂá∫")
        
        # ÂØºÂá∫ÈÄâÈ°π
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### üìä ‰∫§ÊòìËÆ∞ÂΩïÂØºÂá∫")
            
            export_format = st.selectbox(
                "ÂØºÂá∫Ê†ºÂºè",
                options=["CSV", "Excel", "JSON"],
                index=0
            )
            
            # Êó∂Èó¥ËåÉÂõ¥
            start_date = st.date_input(
                "ÂºÄÂßãÊó•Êúü",
                value=datetime.now() - timedelta(days=30),
                key="export_start"
            )
            end_date = st.date_input(
                "ÁªìÊùüÊó•Êúü",
                value=datetime.now(),
                key="export_end"
            )
            
            if st.button("üì• ÂØºÂá∫‰∫§ÊòìËÆ∞ÂΩï"):
                # ËøáÊª§Êï∞ÊçÆ
                filtered_trades = []
                for trade in self.trade_records:
                    trade_date = trade['time'].date()
                    if start_date <= trade_date <= end_date:
                        filtered_trades.append(trade)
                
                if filtered_trades:
                    df_export = pd.DataFrame(filtered_trades)
                    
                    if export_format == "CSV":
                        csv = df_export.to_csv(index=False)
                        st.download_button(
                            label="‰∏ãËΩΩCSVÊñá‰ª∂",
                            data=csv,
                            file_name=f"trade_records_{start_date}_to_{end_date}.csv",
                            mime="text/csv"
                        )
                    elif export_format == "Excel":
                        # ËøôÈáåÈúÄË¶ÅÂÆûÁé∞ExcelÂØºÂá∫
                        st.info("ExcelÂØºÂá∫ÂäüËÉΩÂºÄÂèë‰∏≠...")
                    elif export_format == "JSON":
                        json_data = df_export.to_json(orient='records', date_format='iso')
                        st.download_button(
                            label="‰∏ãËΩΩJSONÊñá‰ª∂",
                            data=json_data,
                            file_name=f"trade_records_{start_date}_to_{end_date}.json",
                            mime="application/json"
                        )
                else:
                    st.warning("ÊâÄÈÄâÊó∂Èó¥ÊÆµÂÜÖÊ≤°Êúâ‰∫§ÊòìÊï∞ÊçÆ")
        
        with col2:
            st.markdown("#### üìã Á≥ªÁªüÊó•ÂøóÂØºÂá∫")
            
            log_level = st.selectbox(
                "Êó•ÂøóÁ∫ßÂà´",
                options=["ÂÖ®ÈÉ®", "INFO", "WARNING", "ERROR", "DEBUG"],
                index=0,
                key="export_level"
            )
            
            log_source = st.selectbox(
                "Êó•ÂøóÊù•Ê∫ê",
                options=["ÂÖ®ÈÉ®"] + list(set([log['source'] for log in self.system_logs])),
                index=0,
                key="export_source"
            )
            
            if st.button("üì• ÂØºÂá∫Á≥ªÁªüÊó•Âøó"):
                # ËøáÊª§Êó•Âøó
                filtered_logs = self._filter_logs(log_level, log_source, "")
                
                if filtered_logs:
                    df_logs = pd.DataFrame(filtered_logs)
                    csv = df_logs.to_csv(index=False)
                    st.download_button(
                        label="‰∏ãËΩΩÊó•ÂøóÊñá‰ª∂",
                        data=csv,
                        file_name=f"system_logs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )
                else:
                    st.warning("Ê≤°ÊúâÂåπÈÖçÁöÑÊó•ÂøóÊï∞ÊçÆ")
        
        # Ëá™Âä®Â§á‰ªΩËÆæÁΩÆ
        st.markdown("---")
        st.markdown("#### ‚öôÔ∏è Ëá™Âä®Â§á‰ªΩËÆæÁΩÆ")
        
        col1, col2 = st.columns(2)
        
        with col1:
            auto_backup = st.checkbox("ÂêØÁî®Ëá™Âä®Â§á‰ªΩ", value=False)
            backup_interval = st.selectbox(
                "Â§á‰ªΩÈ¢ëÁéá",
                options=["ÊØèÂ∞èÊó∂", "ÊØèÂ§©", "ÊØèÂë®"],
                index=1
            )
        
        with col2:
            backup_location = st.text_input(
                "Â§á‰ªΩ‰ΩçÁΩÆ",
                value="./backups/",
                placeholder="ËæìÂÖ•Â§á‰ªΩÁõÆÂΩïË∑ØÂæÑ"
            )
            
            if st.button("üíæ Á´ãÂç≥Â§á‰ªΩ"):
                st.success("Â§á‰ªΩÂ∑≤ÂàõÂª∫ÔºÅ")
                st.info(f"Â§á‰ªΩ‰øùÂ≠òËá≥: {backup_location}")
        
        if auto_backup:
            st.success(f"‚úÖ Ëá™Âä®Â§á‰ªΩÂ∑≤ÂêØÁî®ÔºåÈ¢ëÁéá: {backup_interval}")
        else:
            st.info("‚ÑπÔ∏è Ëá™Âä®Â§á‰ªΩÂ∑≤Á¶ÅÁî®")